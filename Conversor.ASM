;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 12F675                   *
;*                FEITAS PELO PROF. MARDSON                        *
;*                    FEVEREIRO DE 2014                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       NOME DO PROJETO                           *
;*                           CLIENTE                               *
;*         DESENVOLVIDO PELA MOSAICO ENGENHARIA E CONSULTORIA      *
;*   VERSÃO: 1.0                           DATA: 17/06/03          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 12F675                                      *
;*                                                                 *
;*                                                                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p12f675.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES
		INICIA		;VARIÁVEL PARA INICIAR O LCD
	
		DADO		;ARMAZENA O DADO PARA A EEPROM
		DADO1
		DADO2
		CONT
		CONT2
		CONT3
		CONT_AUX
		AUX
		DELAY_TEMP
		MEDIA1
		MEDIA2
		MEDIA_AUX
		
		;NOVAS VARIÁVEIS

	ENDC			;FIM DO BLOCO DE MEMÓRIA
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA
; INICIALIZAÇÃO DA EEPROM, DE ACORDO COM A DESCRIÇÃO NO ARQUIVO "Def_Rega_Formigas.inc"

;A PARTIR DO ENDEREÇO ZERO DA EEPROM, DADOS EM ORDEM ALEATÓRIA
	ORG 0x2100
		;A   l    e    x    a    n    d    r    e
	DE	0X41,0X6C,0X65,0X78,0X61,0X6E,0X64,0X72,0X65


;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.
LE_EEPROM
;LER DADO DA EEPROM, CUJO ENDEREÇO É INDICADO EM W
;DADO LIDO RETORNA EM W
	ANDLW	.127		;LIMITA ENDEREÇO MAX. 127
	BANK1				;ACESSO VIA BANK 1
	MOVWF	EEADR		;INDICA O END. DE LEITURA
	BSF		EECON1,RD	;INICIA O PROCESSO DE LEITURA
	MOVF	EEDATA,W	;COLOCA DADO LIDO EM W
	BANK0				;POSICIONA PARA BANK 0
	RETURN

GRAVA_EEPROM
;ESCREVE DADO (DADO) NA EEPROM, CUJO ENDEREÇO É INDICADO EM W
	ANDLW	.127		;LIMITA ENDEREÇO MAX. 127
	BANK1				;ACESSO VIA BANK 1
	MOVWF	EEADR
	MOVF	DADO,W
	MOVWF	EEDATA
	BSF		EECON1,WREN ;HABILITA ESCRITA
	BCF		INTCON,GIE	;DESLIGA INTERRUPÇÕES
	MOVLW	B'01010101'	;DESBLOQUEIA ESCRITA
	MOVWF	EECON2		;
	MOVLW	B'10101010'	;DESBLOQUEIA ESCRITA
	MOVWF	EECON2		;
	BSF		EECON1,WR ;INICIA A ESCRITA
AGUARDA
	BTFSC	EECON1,WR ;TERMINOU?
	GOTO	AGUARDA
	BSF		INTCON,GIE ;HABILITA INTERRUPÇÕES
	BANK0				;POSICIONA PARA BANK 0
	RETURN

SUBROTINA1
	;CORPO DA ROTINA
;SUBROTINA PARA TRATAR MEUS DADOS
TRATAR_DADOS
	MOVLW	.4 ;COMO IREI DIVIDIR O MEU BYTE UTILIZANDO 4 BITS PARA CADA VARIÁVEL
	MOVWF	CONT2	;INICIALMENTE PEGAREMOS OS 4 BITS MAIS SIGNIFICATIVOS
LOOP_DIV	
	RRF	DADO1
	BTFSS	DADO,7
	GOTO	CLEAR_DADO
	GOTO	SET_DADO
CLEAR_DADO
	BCF	DADO1,3
	GOTO	SAIR
SET_DADO
	BSF	DADO1,3
SAIR	
	RLF	DADO
	DECFSZ	CONT2
	GOTO	LOOP_DIV
	;PREENCHER DADO2
	MOVLW	.4  ;COMO IREI DIVIDIR O MEU BYTE UTILIZANDO 4 BITS PARA CADA VARIÁVEL
	MOVWF	CONT2	;POR ÚLTIMO PEGAREMOS 4 BITS MENOS SIGNIFICATIVOS
LOOP_DIV2	
	RRF	DADO2
	BTFSS	DADO,7
	GOTO	CLEAR_DADO2
	GOTO	SET_DADO2
CLEAR_DADO2
	BCF	DADO2,3
	GOTO	SAIR2
SET_DADO2
	BSF	DADO2,3
SAIR2	
	RLF	DADO
	DECFSZ	CONT2
	GOTO	LOOP_DIV2
	
	BSF	DADO1,4  ;SETANDO PARA O LCD IDENTIFICAR QUE É UMA ESCRITA DE DADOS
	BSF	DADO2,4	 ;SETANDO PARA O LCD IDENTIFICAR QUE É UMA ESCRITA DE DADOS
	RETURN
	
	
DELAY
	;FUNÇÃO PARA FAZER DELAY COM QUALQUER TEMPO
	MOVWF	TMR0
	BCF	INTCON, T0IF
LOOP_1
	BTFSS	INTCON,	T0IF
	GOTO	LOOP_1
	RETURN
	
;SUBROTINA PARA COLOCAR MEUS DADOS NO REGISTRADOR DE DESLOCAMENTO
REG_DESLOC
	BTFSS	INICIA,0
	GOTO	CLEAR_GP4
	GOTO	SET_GP4
CLEAR_GP4
	BCF	GPIO,GP4
	GOTO	CLOCK_REG
SET_GP4
	BSF	GPIO,GP4
CLOCK_REG ;CLOCK PARA DESLOCAR O DADO NO REGISTRADOR
	BSF	GPIO,GP0
	BCF	GPIO,GP0
	RRF	INICIA
	DECFSZ	CONT,F
	GOTO	REG_DESLOC
	;QUATRO PULSOS DE CLOCK PARA AJUSTAR MEU DADO NO REGISTRADOR
	BSF	GPIO,GP0
	BCF	GPIO,GP0
	BSF	GPIO,GP0
	BCF	GPIO,GP0
	BSF	GPIO,GP0
	BCF	GPIO,GP0
	BSF	GPIO,GP5
	BCF	GPIO,GP5
	RETURN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1				;ALTERA PARA O BANCO 1
	MOVLW	B'00000100' ;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISIO		;COMO SAÍDAS MENOS PORTA GP2, QUE ESTÁ COMO ENTRADA
	MOVLW	B'00010100'
	MOVWF	ANSEL 		;DEFINE PORTAS GP2 COMO ENTRADA ANALÓGICA E UTILIZA FOSC/8
	MOVLW	B'00000101'	;DEFININDO PRESCALE 1:64
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
	MOVLW	B'00000000'
	MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	BANK0				;RETORNA PARA O BANCO
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO
	MOVLW	B'00001001'
	MOVWF	ADCON0		;DEFINE A CONVERSÃO PARA AN2

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MAIN
	;CORPO DA ROTINA PRINCIPAL
	;CONFIGURANDO O LCD. FAZENDO SUA INICIALIZAÇÃO
	MOVLW	.6
	CALL	DELAY
	MOVLW	B'00001100'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;ESPERAR CERCA DE 5ms
	MOVLW	.176
	CALL	DELAY
	MOVLW	B'00001100'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00001100'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;Function set ( Set interface to be 4 bits long. ) Interface is 8 bits in length.
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000100'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;Function set ( Interface is 4 bits long. Specify the number of display lines and character font. )
	;The number of display lines and character font can not be changed after this point.
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000100'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;PARTE 2 DO SYSTEM SET
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000011'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;Display ON
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000000'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;PARTE 2 DISPLAY ON
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000011'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;Display clear
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000000'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;PARTE 2 Display clear
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00001000'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;Entry mode set
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000000'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;PARTE 2 Entry mode set
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000100'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;ESCREVER OS DADOS!
	MOVLW	.200
	CALL	DELAY
	
;COMEÇO DA CONVERSÃO	
CONVERSAO	
	MOVLW   .32	;VAIAVEL CONT RECEBE 32, PORQUE SÃO 32 VALORES QUE É
	MOVWF   CONT	;PRECISO PEGAR PARA FAZER A MÉDIA
	MOVLW   0X30	;APONTANDO PARA O ENDEREÇO 0X30 DA MEMÓRIA
	MOVWF   FSR
LOOP1
	BSF	ADCON0, 1   ;ACIONO A CONVERSÃO
VOLTA	
	BTFSS   PIR1, ADIF  ;CONFIRO SE A FLAG DA CONVERSÃO FOI ACIONADA
	GOTO    VOLTA	    ;SE NÃO, CONTINUA ESPERANDO A CONVERSÃO
	MOVFW   ADRESH	    ;O VALOR DA CONVERSÃO FICOU SALVA NESSE REGISTRADOR
	MOVWF   INDF	    ;E COLOCO O VALOR DA CONVERSÃO NO CAMPO APONTADO NA MEMÓRA
	INCF    FSR	    ;INCREMENTO PARA O PRÓXIMO ENDEREÇO DA MEMÓRIA
	BCF	PIR1, ADIF  ;LIMPO A FLAG DO CONVERSOR
	DECFSZ  CONT,F	    ;DECREMENTO O CONT E CONFIRO JA FOI OS 32 VALORES
	GOTO    LOOP1	    ;SE NÃO FOI, VOLTA PARA PEGAR O RESTO DOS VALORES
	
	CLRF	MEDIA1	    ;LIMPO OS VALORES ANTERIORES DAS VARIAVEIS MEDIA1 E 2
	CLRF	MEDIA2	    ;POIS IREI UTILIZAR PARA AS PROXIMAS MÉDIAS
	MOVLW   .32	    ;NOVAMENTE COLOCO O CONT PARA 32, PARA PEGAR OS 32
	MOVWF   CONT	    ;VALORES NA MEMÓRIA
	MOVLW   0X30	    ;APONTO NOVAMENTE O PONTEIRO PARA A POSIÇÃO 0X30 DA MEMÓRIA
	MOVWF   FSR
CALC_MEDIA
	MOVFW	INDF	    ;MOVO O VALOR DA MEMÓRIA PARA O WORK, PARA PODER SOMAR
	ADDWF	MEDIA1,F    ;COM A VARIÁVEL MEDIA1
	BTFSS	STATUS,C    ;SE O BYTE ESTOURAR	EU INCREMENTO 1 NA PROXIMA VARIÁVEL
	GOTO	DEPOIS_DO_INC	;PULAR O INCREMENTO
	INCF	MEDIA2,F    ;COMO ESTOUROU O BYTE DA MEDIA1, INCREMENTEI 1 NO MEDIA2
DEPOIS_DO_INC
	INCF    FSR	    ;AGORA INCREMENTO O VALOR DO PONTEIRO PARA PEGAR O PROX ENDEREÇO DA MEMÓRIA
	DECFSZ	CONT,F	    ;CONFIRO SE JA FOI FEITO A SOMA DOS 32 VALORES
	GOTO	CALC_MEDIA  ;SE NÃO SOMOU TODOS OS VALORES, VOLTO PARA CONTINUAR A SOMA
	MOVLW   .5	    ;SE JA FOI FEITO A SOMA, VAMOS FAZER A MÉDIA
	MOVWF   CONT	    ;COMO SÃO 32 VALORES, SÓ É PRECISO ROTACIONAR PARA A DIREITA 5 VEZES
MEDIA	
	RRF	MEDIA2	    ;ROTACIONO PRIMEIRO A VARIAVEL MEDIA2 QUE TEM VALORES MAIS SIGNIFICATIVOS
	RRF	MEDIA1	    ;E OS VALORES VAI PARA O CARRY, E ROTACIONO O MEDIA1 QUE PEGA O VALOR DO CARRY
	DECFSZ	CONT,F	    ;CONFIRO SE FOI ROTACIONADO 5 VEZES
	GOTO	MEDIA	    ;SE NÃO, CONTINUO ROTACIONANDO 
	
	;AGORA SERÁ FEITO OS CÁLCULOS PARA SABER A PORCENTAGEM
	MOVLW	.100	    ;COLOCO 100 NO CONT, POIS SERÁ NECESSÁRIO MULTIPLICAR POR 100
	MOVWF	CONT	    ;NO CASO SERÁ FEITO SOMAS CONSECUTIVAS 100 VEZES
	CLRF	MEDIA2	    ;LIMPO MEDIA2 PARA PODER UTILIZA-LO
	MOVFW	MEDIA1	    ;MOVO O VALOR DE MEDIA1 PARA MEDIA_AUX PARA PODER SALVAR O VALOR
	MOVWF	MEDIA_AUX   ;ANTES DE FAZER ALTERAÇÕES
SOMA
	MOVFW	MEDIA_AUX   ;AGORA UTILIZO O PRIMEIRO VALOR DO MEDIA1, E FAÇO SOMAS 
	ADDWF	MEDIA1	    ;CONSECUTIVAS, QUE É EQUIVALENTE DE MULTIPLICAR POR 100
	BTFSS	STATUS,C    ;TESTO SE O VALOR DO BYTE ESTOUROU, SE ESTOUROU EU INCREMENTO O MEDIA2
	GOTO	DEPOIS_INC_SOMA	;SE NÃO ESTOROU EU PULO O INCREMENTO
	INCF	MEDIA2,F    ;INCREMENTA O MEDIA2
DEPOIS_INC_SOMA
	DECFSZ	CONT,F	    ;DECREMENTO A VARIAVEL CONT PARA SABER SE JA TERMINOU A MULTIPLICAÇÃO
	GOTO	SOMA	    ;SE NÃO TERMINOU, CONTINUA FAZENDO AS SOMAS CONSECUTIVAS
	
	;COMO É PRECISO DIVIDIR POR 256, SERIA A MESMA COISA DE ROTACIONAR MEDIA2 E MEDIA1 8 VEZES
	;LOGO A PORCENTAGEM DA MEDIA É O PRÓPRIO VALOR DE MEDIA2
	;AGORA É NECESSÁRIO SEPARAR A UNIDADE DA DEZENA
	MOVLW	.0	    ;COLOCO O CONT_AUX EM 0
	MOVWF	CONT_AUX
DECOMPONDO	
	MOVFW	MEDIA2	    ;E MOVO O VALOR DE MEDIA2 PARA MEDIA1
	MOVWF	MEDIA1
	MOVLW	.10	    ;E SUBTRAIO 10 DE MEDIA2
	SUBWF	MEDIA2,F
	BTFSS	STATUS,C    ;SE FOR POSITIVO CONTINUA SUBTRAINDO POR 10
	GOTO	FIM_DECOMPOSICAO    ;SE DER NEGATIVO É PORQUE SÓ SOBROU A UNIDADE
	INCF	CONT_AUX    ;INCREMENTO O DO CONT_AUX, PORQUE ELE QUE SERÁ NOSSA DEZENA
	GOTO	DECOMPONDO  ;E CONTINUO SUBTRAINDO POR 10
FIM_DECOMPOSICAO
	;CLEAR LCD
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000000'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;PARTE 2 Display clear
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00001000'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	
	;Entry mode set
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000000'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;PARTE 2 Entry mode set
	;ESPERAR CERCA DE 128us
	MOVLW	.254
	CALL	DELAY
	MOVLW	B'00000100'
	MOVWF	INICIA
	MOVLW	.5
	MOVWF	CONT
	CALL	REG_DESLOC
	;ESCREVER OS DADOS!
	MOVLW	.200
	CALL	DELAY
	
	MOVLW	.10	    ;SUBTRAIO O CONT_AUX POR 10 E SALVO NO WORK PARA SABER
	SUBWF	CONT_AUX,W  ;SE DEU 100% OU NÃO
	BTFSS	STATUS, Z   ;CONFIRO SE DEU 100%
	GOTO	NAO_100	    ;QUANDO NÃO FOR 100%
	
	MOVLW	.49	    ;SE DEU 100%
	MOVWF	DADO	    ;MOVO O VALOR 1 NA TABELA ASCII EM DADO
	CALL	TRATAR_DADOS	;TRATO OS DADOS PARA COLOCAR NO LCD
	MOVFW	DADO1	    ;MOVO O VALOR DE DADO1 PARA A VARIVEL INICIA QUE 
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT	
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	MOVLW	.254	    ;DOU UM DELAY PARA PODER ESCREVER
	CALL	DELAY
	;DEPOIS ENVIO A SEGUNDA PARTE DA LETRA PARA O LCD
	MOVFW	DADO2	    ;MOVO O VALOR DE DADO2 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	
	MOVLW	.48	    
	MOVWF	DADO	    ;MOVO O VALOR 0 NA TABELA ASCII EM DADO
	CALL	TRATAR_DADOS	;TRATO OS DADOS PARA COLOCAR NO LCD	
	MOVFW	DADO1	    ;MOVO O VALOR DE DADO1 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	MOVLW	.254	    ;DOU UM DELAY PARA PODER ESCREVER
	CALL	DELAY
	;DEPOIS ENVIO A SEGUNDA PARTE DA LETRA PARA O LCD
	MOVFW	DADO2	    ;MOVO O VALOR DE DADO2 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	
	MOVLW	.48	    
	MOVWF	DADO	    ;MOVO O VALOR 0 NA TABELA ASCII EM DADO
	CALL	TRATAR_DADOS	;TRATO OS DADOS PARA COLOCAR NO LCD	
	MOVFW	DADO1	    ;MOVO O VALOR DE DADO1 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	MOVLW	.254	    ;DOU UM DELAY PARA PODER ESCREVER
	CALL	DELAY
	;DEPOIS ENVIO A SEGUNDA PARTE DA LETRA PARA O LCD
	MOVFW	DADO2	    ;MOVO O VALOR DE DADO2 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	
	GOTO	PORCENTO    ;VOU PARA PRINTAR O SINAL %
	;SE NÃO  FOR 100%, VAMOS PRINTAR O VALOR EQUIVALENTE DA CASA DA DEZENA E UNIDADE
NAO_100	
	MOVLW	.48	    ;SOMO O VALOR DA DEZENA COM 48 PARA DAR O VALOR CERTO NA TABELA ASCII
	ADDWF	CONT_AUX,F  
	MOVFW	CONT_AUX    ;MOVO O VALOR PARA EQUIVALENTE EM ASCII PARA O WORK
	MOVWF	DADO	    ;MOVO PARA A VARIAVEL DADO PARA TRATAR ESSE VALOR
	CALL	TRATAR_DADOS	;PARA COLOCAR NO LCD, CHAMO A FUNÇÃO PARA TRATAR ESSE DADO
	MOVFW	DADO1	    ;MOVO O VALOR DE DADO1 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	MOVLW	.254	    ;DOU UM DELAY PARA PODER ESCREVER
	CALL	DELAY
	;DEPOIS ENVIO A SEGUNDA PARTE DA LETRA PARA O LCD
	MOVFW	DADO2	    ;MOVO O VALOR DE DADO2 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	
	;SOMO O VALOR DA UNIDADE COM 58, POIS EM UM CERTO MOMENTO EU SUBTRAI UMA VEZ A MAIS POR 10
	MOVLW	.58	    ; PARA DAR O VALOR CERTO NA TABELA ASCII	
	ADDWF	MEDIA2,F
	MOVFW	MEDIA2	    ;MOVO O VALOR PARA EQUIVALENTE EM ASCII PARA O WORK
	MOVWF	DADO	    ;MOVO PARA A VARIAVEL DADO PARA TRATAR ESSE VALOR
	CALL	TRATAR_DADOS	;PARA COLOCAR NO LCD, CHAMO A FUNÇÃO PARA TRATAR ESSE DADO
	MOVFW	DADO1	    ;MOVO O VALOR DE DADO1 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	MOVLW	.254	    ;DOU UM DELAY PARA PODER ESCREVER
	CALL	DELAY
	;DEPOIS ENVIO A SEGUNDA PARTE DA LETRA PARA O LCD
	MOVFW	DADO2	    ;MOVO O VALOR DE DADO2 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
PORCENTO	
	MOVLW	.37	    ;MOVO O VALOR % NA TABELA ASCII EM DADO
	MOVWF	DADO
	CALL	TRATAR_DADOS	;PARA COLOCAR NO LCD, CHAMO A FUNÇÃO PARA TRATAR ESSE DADO
	MOVFW	DADO1	    ;MOVO O VALOR DE DADO1 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	MOVLW	.254	    ;DOU UM DELAY PARA PODER ESCREVER
	CALL	DELAY
	;DEPOIS ENVIO A SEGUNDA PARTE DA LETRA PARA O LCD
	MOVFW	DADO2	    ;MOVO O VALOR DE DADO2 PARA A VARIVEL INICIA QUE
	MOVWF	INICIA	    ;UTILIZO PARA PRINTAR NO LCD
	MOVLW	.5	    ;COLOCO 5 NO CONT PARA DESLOCAR O REGISTRADOR DE DESLOCAMENTO
	MOVWF	CONT
	CALL	REG_DESLOC  ;CHAMO A FUNÇÃO PARA DESLOCAR OS BITS NO REGISTRADOR
	
	MOVLW	.20	    ;UTILIZO 20 NO DELAY_TEMP, PARA CONSEGUIR FAZER UM TEMPO DE
	MOVWF	DELAY_TEMP  ;200ms, ja contando com todos os tempos das instruções anteriores
DELAY_200	
	MOVLW	.106	    ;MOVO 106 PARA O WORK E CHAMO A FUNÇÃO DELAY
	CALL	DELAY	
	DECFSZ	DELAY_TEMP,F	;DECREMENTO E CONFIRO SE O DELAY_TEMP ZEROU
	GOTO	DELAY_200   ;SE NÃO ZEROU CONTINUO CONTANDO O TEMPO
	GOTO	CONVERSAO   ;SE ZEROU VOLTO PARA A CONVERSÃO
FIM
	GOTO FIM

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       FIM DO PROGRAMA                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END
